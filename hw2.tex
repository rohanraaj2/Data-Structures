\documentclass[addpoints]{exam}

\usepackage{caption}
\usepackage{graphbox}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{pythonhighlight}
\usepackage{ragged2e}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{titling}
\usepackage{xcolor}
\usepackage{float}

% Header and footer.
\pagestyle{headandfoot}
\runningheadrule
\runningfootrule
\runningheader{CS 201, Spring 2023}{HW 2: Skiplists and Dynamic List ADT}{\theauthor}
\runningfooter{}{Page \thepage\ of \numpages}{}
\firstpageheader{}{}{}

\qformat{{\large\bf \thequestion. \thequestiontitle}\hfill[\totalpoints\ points]}
% \qformat{{\large\bf \thequestion. \thequestiontitle}\hfill}
\boxedpoints

\printanswers

\graphicspath{{images/}}

\newcommand\colheader[1]{\multicolumn{1}{c}{#1}} % Note: no vertical bars

\title{Homework 2: Skiplists and Dynamic List ADT}
\author{unknown}  % <=== Enter your team name.
\date{Habib University\\Spring 2023}

\begin{document}
\maketitle
\part{Dynamic List ADT}

In this assignment, you will implement a dynamic list ADT in Python that allows for inserting and deleting elements at a specified index and retrieving elements at a specified index.
The list should be implemented as both a dynamic array and a linked list.


\section{Implementation Details and Tasks}

\begin{itemize}
  \item Implement the \pyth{DynamicArrayList} and \pyth{LinkedList} classes in the accompanying file, \texttt{listadt.py}, in the accompanying \texttt{src/} sub-folder.
  \item In the \pyth{DynamicArrayList} and \pyth{LinkedList} classes, implement the following methods:
        \begin{itemize}
          \item \pyth{insert(index, value)}: inserts value at the specified index
          \item \pyth{delete(index)}: deletes the element at the specified index
          \item \pyth{get(index)}: returns the element at the specified index
          \item \pyth{size()}: returns the number of elements in the list
          \item \pyth{display()}: returns the string representation of the list
        \end{itemize}
  \item The dynamic array should be implemented using Python \pyth{arrays}. Upon creation, the dynamic array will have a size of one, and all empty items will be initialised as -1.
  \item The dynamic array should dynamically resize itself when necessary to ensure efficient use of memory i.e., \textbf{the array should double it's size when it is full
          and reduce by half once it is quarter the size of array.}
  \item The cost of resizing the array should be linear in the size of the array.
  \item The linked list should be implemented as a singly linked list.
  \item The program should take as an input a file that specifies which data structure should be used to implement the dynamic list ADT and which operations should be performed on the list.
  \item The program should read the input file, create the appropriate data structure, and perform the specified operations. The program should then output the result of each operation.
  \item The function \pyth{load} which parses the input file and saves the output of the program to a given file, has already been implented in the accompanying file, \texttt{listadt.py}, in the accompanying \texttt{src/} sub-folder.
\end{itemize}


\subsection{Input and Output}

The input file will specify which data structure should be used to implement the Dynamic List ADT and which operations should be performed on the list. The input file will have the following format:
\begin{center}
  \begin{tabular}{c}
    \begin{lstlisting}[language={}]
    <data structure>
    <operation> <arg1> <arg2>
    \end{lstlisting}
  \end{tabular}
\end{center}
\begin{itemize}
  \item $\langle$\textbf{data structure}$\rangle$ is either array or linkedlist, indicating which data structure should be used to implement the Dynamic List ADT
  \item $\langle$ \textbf{operation}$\rangle$ is one of the following:
        \begin{itemize}
          \item \textbf{insert}: Insert an item into the list. The $\langle$arg1$\rangle$ is the index at which to insert the item and $\langle$arg2$\rangle$ is the item to be inserted.
          \item \textbf{delete}: Delete an item from the list. The $\langle$arg1$\rangle$ is the index of the item to be deleted.
          \item \textbf{get}: Return the item at the specified index in the list. The $\langle$arg1$\rangle$ is the index of the item to be returned.
          \item \textbf{size}: Return the number of items in the list.
          \item \textbf{display}: Return the string representation of the list.

        \end{itemize}
\end{itemize}
The output of the program will be the result of each operation, one per line.

\subsection{Example}
In the following examples, the input file specifies which data structure should be used to implement the Dynamic List ADT. The program then performs the specified operations on the list and outputs the result of each operation.

% \begin{table}[h]
%   \centering
%   \begin{tabular}{|ccc|}
%     \hline
%     linkedlist &   &    \\
%     insert     & 0 & 10 \\
%     insert     & 0 & 20 \\
%     insert     & 1 & 30 \\
%     get        & 0 &    \\
%     get        & 1 &    \\
%     get        & 2 &    \\
%     delete     & 1 &    \\
%     size       &   &    \\
%     display    &   &    \\
%     \hline
%   \end{tabular}
%   \caption*{Sample Input}

%   \begin{tabular}{|ccc|}
%     \hline
%     20         &  & \\
%     30         &  & \\
%     10         &  & \\
%     2          &  & \\
%     $[20, 10]$ &  & \\
%     \hline
%   \end{tabular}
%   \caption*{Sample Output}
%   \caption{Example Input \& Output  -- LinkedList}
% \end{table}
\subsubsection{Linked List}
\lstinputlisting[language={}, caption={Sample input file for creating a LinkedList}, captionpos=b,frame=single]{data/input.txt}
\lstinputlisting[language={}, caption={Sample output generated by the program}, captionpos=b,frame=single]{data/output.txt}
\subsubsection{Dynamic Array List}
\lstinputlisting[language={}, caption={Sample input file for creating a DynamicArrayList}, captionpos=b,frame=single]{data/input1.txt}
\lstinputlisting[language={}, caption={Sample output generated by the program}, captionpos=b,frame=single]{data/output1.txt}


\subsection{Testing}
Once you have successfully implemented the \pyth{DynamicArrayList} and \pyth{LinkedList} classes, you can test your code by reading from the accompanying data file, \texttt{data/input.txt}, and performing operations on the list adt. For grading purposes, your submission will be tested automatically by GitHub using the accompanying \pyth{pytest} file, \texttt{test\_listadt.py}.

\newpage
\part{Skiplists}

The solutions to the problems in this part are to be entered inline below. Remove all the other parts and sections from this document. Enter your team name as the author in the document's title.

\begin{questions}

  \titledquestion{A Ranked Set}[10]\footnote{Adapted from Exercise 4.9 in the textbook.}
  Design a version of a skiplist that implements the \texttt{SSet} interface, but also allows fast access to elements by \textit{rank}. That is, it also supports the function \texttt{get(i)}, which returns the element whose rank is \texttt{i} in $O(\log n)$ expected time. (The rank of an element \texttt{x} in an \texttt{SSet} is the number of elements in the \texttt{SSet} that are less than \texttt{x}.)
  Describe how your version differs from a regular skiplist and provide pseudocode of \texttt{find(x)} and \texttt{get(i)} for this version.
  \begin{solution}
    % Enter your solution here.
  \end{solution}

  \titledquestion{Finger Search}[10]\footnote{Adapted from Exercise 4.10 in the textbook.}
  A \textit{finger} in a skiplist is an array that stores the sequence of nodes on a search path at which the search path goes down. (The variable \texttt{stack} in the \texttt{add(x)} code on page 87 is a finger; the shaded nodes in Figure 4.3 show the contents of the finger.) One can think of a finger as pointing out the path to a node in the lowest list, $L_0$.

  A \textit{finger search} implements the find(x) operation using a finger, walking up the list using the finger until reaching a node \texttt{u} such that \texttt{u.x < x} and \texttt{u.next = nil} or \texttt{u.next.x > x} and then performing a normal search for \texttt{x} starting from \texttt{u}. It is possible to prove that the expected number of steps required for a finger search is $O(1+\log r)$, where $r$ is the number values in $L_0$ between \texttt{x} and the value pointed to by the finger.

  Design, i.e. provide the necessary pseudo code for, a version of a skiplist that implements \texttt{find(x)} operations using an internal finger. This subclass stores a finger, which is then used so that every \texttt{find(x)} operation is implemented as a finger search. During each \texttt{find(x)} operation the finger is updated so that each \texttt{find(x)} operation uses, as a starting point, a finger that points to the result of the previous \texttt{find(x)} operation.
  \begin{solution}
    % Enter your solution here.
  \end{solution}


\end{questions}

\newpage
\part{Implementing a Database Index using a Skiplist}

\begin{figure}[!h]
  \centering
  \includegraphics[width=.8\linewidth]{index}
  \caption{An index over the Name attribute of a table. The index stores values of the Name attribute as keys with the associated value being the address of the corresponding record in the table.}
  \label{fig:index}
\end{figure}

You have learned about database indexes in CS 355 Database Systems. Indexes in databases are similar to indexes in books. In a book, an index allows you to find information quickly without reading the entire book. In a database, an index allows the database program to find data in a table without scanning the entire table. An index in a book is a sorted list of words with the page numbers that contain each word. An index in a database is a sorted list of key values with the storage locations of rows in the table that contain the key value. Each key in the index is associated with a particular pointer to a record in the data file. Figure \ref{fig:index} shows an index on the \textit{Name} attribute of an \textit{Instructor} table stored in a data file. Note that key values in the figure are not sorted.

The most popular data structure used for indexing in relational databases is Btree (or its variant, such as B+tree). Btrees rose to popularity because they do fewer disk I/O operations to run a lookup compared to other balanced trees. SingleStore is the first commercial relational database in production today to use a skiplist, not a Btree, as its primary index data structure for in-memory data \cite{singlestore}.

You are given a data file, \texttt{data/books.csv}, that contains records of books. Each record contains the following attributes:
\begin{itemize}
  \item Book Code
  \item Title
  \item Category
  \item Price
  \item Number of Pages
\end{itemize}
For some of the attributes, all the values are unique. Such attributes can be used to index the table. Others have repeating values and are thus unsuitable to be used for indexing.

\section{Implementation Details and Tasks}

You are required to provide the missing implementations for the methods in the files, \texttt{skiplist.py} and \texttt{db.py}, in the accompanying \texttt{src/} sub-folder. \texttt{skiplist.py} contains classes to implement a skiplist. \texttt{db.py} contains a \pyth{Table} class to store records which can be indexed using a skiplist. Every individual field in the \pyth{Table} is stored as strings. Further details are provided in the doc strings in the files. The methods to be implemented are identified with a \pyth{pass} in their body.

\subsection{Requirement}

You will need to install the \pyth{typing} module to support certain type hints used in the code.

\subsection{Tips}

Below are some tips to avoid the errors that have previously caused tests to fail. Following these may save you many frustrating hours of debugging!
\begin{itemize}
  \item Store each field that is read from file as a \pyth{str}.
  \item Store a record as a list of field values.
  \item Store a table as a collection of records.
  \item Make sure that the \pyth{Table} can be re-indexed during run-time.
  \item Take care that the keys for the index are the values of the specified attribute. And that the value associated with each key is not the corresponding record, but a means to locate the record in the table.
  \item For the \pyth{select_range} query, think of an approach better than submitting multiple \pyth{select} queries.
\end{itemize}

\subsection{Testing}

Once you have successfully implemented the methods, you can test your code by reading from the accompanying data file, \texttt{data/books.csv}, and performing queries on it. For grading purposes, your submission will be tested automatically by GitHub using the accompanying \pyth{pytest} file, \texttt{test\_index.py}.

\newpage


\newpage
\newpage
\begin{thebibliography}{9}

  \bibitem{singlestore}
  The Story Behind SingleStore’s Skiplist Indexes, \url{https://www.singlestore.com/blog/what-is-skiplist-why-skiplist-index-for-memsql/}, last accessed on 16 Feb 2022.
  \end{thebibliography}
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
